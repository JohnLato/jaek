{-# LANGUAGE TupleSections #-}

module Jaek.UI.Controllers.Drags (
  selectCtrl
 ,dragToRegions
)

where

import Jaek.Base
import Jaek.Tree
import Jaek.UI.Controllers.Base
import Jaek.UI.FrpHandlers
import Jaek.UI.Render.Overlays
import Jaek.UI.Views

import Reactive.Banana  as FRP
import Diagrams.Prelude as D
import Data.Foldable (toList)
import Data.Label as L
import qualified Data.IntMap as M
import qualified Data.SplayTree.RangeSet as R
import           Data.SplayTree (fmap')

import Control.Arrow

type RMap = M.IntMap (R.RangeSet Double)

-- | apply the monotonic function to all ranges in an RMap
mapRangesMono :: (Double -> Double) -> RMap -> RMap
mapRangesMono f =
  M.map (fmap' (uncurry R.rangePs <<< (f . R.rMin &&& f . R.rangeMax)))

-- The current selection is a Discrete [DragEvent].  There are two components,
-- the current drag event, and any prior selected regions (if the current event
-- is additive).  The selections are cleared by a non-additive click
-- event outside a selected area.
-- 
-- when a click occurs within the current selection, it should be ignored.
--
-- The exposed drags aren't exactly the drag events generated by the user;
-- they all have single-click with no modifiers.  This is necessary because
-- of how multiple regions are combined, to avoid double-processing
-- of overlapping selections.
-- 
-- This controller is only active when a Wave is in focus.
selectCtrl
  :: Discrete (Int,Int)  -- ^ viewport size
  -> Discrete View
  -> Discrete TreeZip
  -> Event ClickEvent    -- ^ clicks
  -> Event ClickEvent    -- ^ releases
  -> Event KeyVal
  -> Event MotionEvent
  -> Controller [DragEvent]
selectCtrl dSize dView dZip clicks releases keys motions =
  nullController { dActive     = isActive
                  ,dState      = dSel
                  ,clickPass   = clicks   -- for now, pass all clicks
                  ,releasePass = releases
                  ,keysPass    = passFilter keys isActive pass2
                  ,motionsPass = motions
                  ,bDiagChange = FRP.value $ compositeSelection
                                 <$> dSel <*> chanCurDrag
                  ,redrawTrig  = (() <$ changes dSel')
                                 <> (() <$ changes chanCurDrag) }
 where
  isActive     = isWaveView <$> dView
  filterActive = filterApply (const <$> FRP.value isActive)
  filtOnPos :: HasXY a => Event a -> Event a
  filtOnPos    = filterApply (FRP.value inSel)
  inSel     :: HasXY a => Discrete (a -> Bool)
  inSel        = (\sels drag ->
                        not (any (\drg -> contains'
                          (fromCorners (P $ L.get xyStart drg)
                                       (P $ L.get xyEnd drg))
                          $ P $ L.get getXY drag) sels) )
                 <$> dSel
  updateFromView :: Event (RMap -> RMap)
  updateFromView = (mapRangesMono <$>) . fst . mapAccum round $
      ((\sz vw lastfn ->
          (sampleCount2px sz vw . lastfn, px2sampleCount sz vw))
       <$> dSize) <@> changes dView
  dAddDrg :: Discrete (Maybe DragEvent -> RMap -> RMap)
  dAddDrg = (\w z mDE rm -> maybe rm (M.unionWith R.append rm
                                  . rngToMap
                                  . dragToRange w z) mDE)
                    <$> dSize <*> dZip
  dSel' :: Discrete RMap
  -- on eAdd, add the current drag to the map
  -- add the current drag if it's the only one.
  -- on escape, clear the current drag.
  --   if it's Nothing, clear the full selection
  dSel' = accumD M.empty $ 
            (dAddDrg <@> sampleD curDrag (eAdd <> (() <$ addSingle)))
            <> clearSel
            <> updateFromView
  unMap = rangesToDrags <$> dSize <*> dZip
  dSel :: Discrete [DragEvent]
  dSel = unMap <*> dSel'
  chanCurDrag = unMap <*> (dAddDrg <*> curDrag <*> pure M.empty)
  curDrag :: Discrete (Maybe DragEvent)
  curDrag  = let cur' = genDDrag (filtOnPos . filterActive $ clicks <> releases)
                          (filterActive motions)
             in stepperD (initial cur')
                         ((Nothing <$ eAdd)
                          <> changes cur'
                          <> (Nothing <$ breaks)
                          <> (Nothing <$ addSingle) )
  clearSel = maybe (const M.empty) (const id) <$> sampleD curDrag breaks
  addSingle = filterApply (FRP.value (const . null <$> dSel)) releases
  (keypass, breaks) = splitEithers (breakKeyF <$> dSel <@> keys)
  breakKeyF [] keyval = Left keyval
  breakKeyF _ keyval
    | keyval == 65307 = Right ()
    | otherwise       = Left keyval
  (pass2, eAdd) = splitEithers (addKey <$> keypass)
  addKey 97 = Right ()
  addKey x  = Left x

rangesToDrags
  :: (Int,Int)
  -> TreeZip
  -> RMap
  -> [DragEvent]
rangesToDrags w z = concatMap (rangeToDrags w z) . M.toList

rangeToDrags :: (Int,Int) -> TreeZip -> (Int, R.RangeSet Double) -> [DragEvent]
rangeToDrags (_, ySz) zp (cNum, rset) = map mkDE $ toList rset
 where
  nc = liftT numChans $ hole zp
  outf y = fI ySz * (fI y / fI nc)
  mkDE rng = DragE (ClickE SingleC [] (R.rMin rng) (outf cNum))
                   (R.rangeMax rng)
                   (outf (cNum+1))

dragToRange
  :: (Int, Int)
  -> TreeZip
  -> DragEvent
  -> [(Int, R.Range Double)]
dragToRange  (_, ySz) zp = getChns
 where
  nc = liftT numChans $ hole zp
  adjf (s,end) = if end >= s then (floor s, ceiling end) else (floor end, ceiling s)
  mkChn drg (mn,mx) = let (xmn,xmx) = get dragXs drg
                      in [ (i, R.rangePs xmn xmx) | i <- [mn .. mx-1]]
  getChns drg = (get dragYs >>> (inf *** inf) >>> adjf >>> mkChn drg) drg
  ySz' = fI ySz :: Double
  nc'  = fI nc :: Double
  inf y = nc' * (y / ySz')

rngToMap :: [(Int, R.Range Double)] -> RMap
rngToMap = M.fromListWith R.append . (map . fmap) R.singleton

-- | usually I use @(Int,SampleCount, SampleCount)@ for the region type,
-- but here it's nested tuples to facilitate further processing
-- 
-- The return type should be interpreted as (Channel, (Offset, Duration))
dragToRegions ::
  (Int, Int)
  -> TreeZip
  -> ViewMap
  -> DragEvent
  -> [(Int, (SampleCount, Duration))]
dragToRegions (xSz, ySz) zp vm drg =
   map (,(xStart,xEnd .-. xStart))
   . uncurry enumFromTo
   . (uncurry min &&& (subtract 1 . uncurry max))
   . (chnBorder *** chnBorder)
   $ L.get dragYs drg
 where
  t  = hole zp
  WaveView off dur = getView vm t
  nc = liftT numChans t
  (xStart,xEnd) = (x2sc . uncurry min &&& x2sc . uncurry max) $ L.get dragXs drg
  x2sc x = off + floor (fI dur * (x / fI xSz))
  chnBorder y = round $ fI nc * (y / fI ySz) :: Int
