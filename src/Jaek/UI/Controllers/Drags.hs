{-# LANGUAGE TupleSections #-}

module Jaek.UI.Controllers.Drags (
  selectCtrl
 ,dragToRegions
)

where

import Jaek.Base
import Jaek.Tree
import Jaek.UI.Controllers.Base
import Jaek.UI.Focus
import Jaek.UI.FrpHandlers
import Jaek.UI.Render.Overlays
import Jaek.UI.Views

import Reactive.Banana  as FRP
import Diagrams.Prelude as D
import Data.Foldable (toList)
import Data.Label as L
import qualified Data.Tuple.Update as T
import qualified Data.IntMap as M
import qualified Data.SplayTree.RangeSet as R

import Control.Arrow
import Control.Monad.Identity


-- The current selection is a Discrete [DragEvent].  There are two components,
-- the current drag event, and any prior selected regions (if the current event
-- is additive).  The selections are cleared by a non-additive click
-- event outside a selected area.
-- 
-- when a click occurs within the current selection, it should be ignored.
--
-- The exposed drags aren't exactly the drag events generated by the user;
-- they all have single-click with no modifiers.  This is necessary because
-- of how multiple regions are combined, to avoid double-processing
-- of overlapping selections.
-- 
-- This controller is only active when a Wave is in focus.
selectCtrl
  :: Discrete (Int,Int)
  -> Discrete Focus
  -> Discrete TreeZip
  -> Event DragEvent
  -> Event ClickEvent    -- ^ clicks
  -> Event ClickEvent    -- ^ releases
  -> Event KeyVal
  -> Event MotionEvent
  -> Controller [DragEvent]
selectCtrl bSize bFocus bZip drags clicks releases keys motions =
  nullController { dActive     = isActive
                  ,dState      = dClean
                  ,clickPass   = clicks   -- for now, pass all clicks
                  ,releasePass = releases
                  ,keysPass    = passFilter keys isActive keypass
                  ,motionsPass = motions
                  ,bDiagChange = compositeSelection <$> value dClean
                  ,redrawTrig  = () <$ changes dSel }
 where
  dClean       = dNoDup <*> dSel
  isActive     = isWave <$> bFocus
  filterActive = filterApply (const <$> value isActive)
  filtOnPos :: HasXY a => Event a -> Event a
  filtOnPos    = filterApply (value inSel)
  inSel     :: HasXY a => Discrete (a -> Bool)
  inSel        = (\sels drag ->
                        not (any (\drg -> contains'
                          (fromCorners (P $ L.get xyStart drg)
                                       (P $ L.get xyEnd drg))
                          $ P $ L.get getXY drag) sels) )
                 <$> dSel
  dSel :: Discrete [DragEvent]
  dSel         = combiner
                 <$> accumD (Nothing, []) (eDrags <> eCurDrag <> breaks)
  -- the current selection is made of two components:
  -- 1.  The current drag region, if it's additive (e.g. shift-drag)
  -- 2.  Everything which is already selected
  combiner (Nothing, rest)   = rest
  combiner (Just this, rest)
    | dragIsAdditive this    = this:rest
    | otherwise              = [this]
  -- need to create Event ((Maybe DE, [DE]) -> (Maybe DE, [DE]) )
  curDrag  = genDDrag (filtOnPos . filterActive $ clicks <> releases)
                      (filterActive motions)
  eCurDrag = T.upd1 <$> (dChannelize <@> changes curDrag)
  eDrags   = (\(Identity drag) ->
                  if dragIsAdditive drag
                    then second (drag: )
                    else second (const [drag]))
             <$> (dChannelize <@> (Identity <$> filtOnPos (filterActive drags)))
  dChannelize :: (Functor f) => Discrete (f DragEvent -> f DragEvent)
  dChannelize = (\w f z s -> fmap (channelizeDrag w f z) s)
                  <$> bSize <*> bFocus <*> bZip
  dNoDup      = (\w z -> rangesToDrags w z . rngToMap
                         . concatMap (dragToRange w z))
                  <$> bSize <*> bZip
  (keypass, breaks) = splitEithers (breakKeyF <$> dSel <@> keys)
  --breakKeyF :: KeyVal -> Either KeyVal ((Maybe DE, [DE]) ->  (Maybe DE, [DE]))
  breakKeyF [] keyval = Left keyval
  breakKeyF _ keyval
    | keyval == 65307 = Right (const (Nothing, []))
    | otherwise       = Left keyval

-- | check if a drag event should be added to current selection (shift-drag)
-- or replace it.
dragIsAdditive :: DragEvent -> Bool
dragIsAdditive = clickIsAdditive . L.get dragStart

clickIsAdditive :: ClickEvent -> Bool
clickIsAdditive = any (== ShiftE) . L.get clickMods

-- | The (X,Y) coordinates of a DragEvent need to be adjusted to match
-- the channels in a WaveView.
channelizeDrag :: (Int, Int) -> Focus -> TreeZip -> DragEvent -> DragEvent
channelizeDrag (_, ySz) focus zp drg
  | isTree focus = drg
  | nc <= 1      = drg
  | otherwise = modify dragYs ((inf *** inf) >>> adjf >>> (outf *** outf)) drg
 where
  nc = liftT numChans $ hole zp
  adjf (s,e) = if e >= s then (floor s, ceiling e) else (ceiling s, floor e)
  ySz' = fI ySz :: Double
  nc'  = fI nc :: Double
  inf y = nc' * (y / ySz')
  outf :: Int -> Double
  outf y = ySz' * (fI y / nc')

rangesToDrags
  :: (Int,Int)
  -> TreeZip
  -> M.IntMap (R.RangeSet Double)
  -> [DragEvent]
rangesToDrags w z = concatMap (rangeToDrags w z) . M.toList

rangeToDrags :: (Int,Int) -> TreeZip -> (Int, R.RangeSet Double) -> [DragEvent]
rangeToDrags (_, ySz) zp (cNum, rset) = map mkDE $ toList rset
 where
  nc = liftT numChans $ hole zp
  outf y = fI ySz * (fI y / fI nc)
  mkDE rng = DragE (ClickE SingleC [] (R.rMin rng) (outf cNum))
                   (R.rangeMax rng)
                   (outf (cNum+1))

dragToRange
  :: (Int, Int)
  -> TreeZip
  -> DragEvent
  -> [(Int, R.Range Double)]
dragToRange  (_, ySz) zp = getChns
 where
  nc = liftT numChans $ hole zp
  adjf (s,e) = if e >= s then (floor s, ceiling e) else (floor e, ceiling s)
  mkChn drg (mn,mx) = let (xmn,xmx) = get dragXs drg
                      in [ (i, R.rangePs xmn xmx) | i <- [mn .. mx-1]]
  getChns drg = (get dragYs >>> (inf *** inf) >>> adjf >>> mkChn drg) drg
  ySz' = fI ySz :: Double
  nc'  = fI nc :: Double
  inf y = nc' * (y / ySz')

rngToMap :: [(Int, R.Range Double)] -> M.IntMap (R.RangeSet Double)
rngToMap = M.fromListWith (R.append) . ((map . fmap) R.singleton)

-- | usually I use @(Int,SampleCount, SampleCount)@ for the region type,
-- but here it's nested tuples to facilitate further processing
dragToRegions ::
  (Int, Int)
  -> TreeZip
  -> ViewMap
  -> DragEvent
  -> [(Int, (SampleCount, SampleCount))]
dragToRegions (xSz, ySz) zp vm drg =
  map (,(xStart,xEnd))
   . uncurry enumFromTo
   . (uncurry min &&& (subtract 1 . uncurry max))
   . (chnBorder *** chnBorder)
   $ L.get dragYs drg
 where
  t  = hole zp
  WaveView off dur = getView vm t
  nc = liftT numChans t
  (xStart,xEnd) = (x2sc . uncurry min &&& x2sc . uncurry max) $ L.get dragXs drg
  x2sc x = off + floor (fI dur * (x / fI xSz))
  chnBorder y = round $ fI nc * (y / fI ySz) :: Int


